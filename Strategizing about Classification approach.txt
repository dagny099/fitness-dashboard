PROJECT: Fitness Dashboard, mid afternoon on 9/9/25

ME: Can you review how this codebase approaches the classification of workouts as Run, Walk, or other?                          │
│   Do we store that in the database so far?                                                                                    │
│   If I wanted to explore the "best" way to do this classification, can you suggest some algorithms, parameters, and           │
│   approaches to store the results? In this dataset, there is no real "correct" answer, since some workouts contain a variety  │
│   of run/walk activities.   


CC: 
⏺ Based on my analysis, here's how the codebase currently approaches workout classification:

  Current Classification System

  Approach: The system uses K-means clustering (not Run/Walk classification) with 3 clusters to classify workouts into:
  - real_run (fastest pace cluster)
  - mixed (medium pace cluster)
  - choco_adventure (slowest pace cluster)

  Features Used: avg_pace, distance_mi, duration_sec

  Storage: Classification results are NOT stored in the database. They're computed on-demand and cached in memory
  (_classification_cache) in src/services/intelligence_service.py:75-186.

  Current Database Schema: Only stores raw workout data - no classification columns exist.

  Suggested Improvements for Run/Walk Classification

  1. Algorithm Options

  Rule-Based (Simplest):
  def classify_pace_based(avg_pace):
      if avg_pace < 12:  # min/mile
          return 'Run'
      elif avg_pace > 20:
          return 'Walk'
      else:
          return 'Mixed'

  Ensemble Approach (Recommended):
  def classify_ensemble(avg_pace, distance_mi, duration_sec, steps):
      # Pace-based score
      pace_score = 1.0 if avg_pace < 10 else (20 - avg_pace) / 10

      # Steps/time ratio (steps per minute)
      spm = steps / (duration_sec / 60) if steps and duration_sec else 0
      step_score = 1.0 if spm > 150 else spm / 150

      # Distance/time ratio consistency
      speed_mph = distance_mi / (duration_sec / 3600) if distance_mi and duration_sec else 0
      speed_score = 1.0 if speed_mph > 6 else speed_mph / 6

      # Weighted ensemble
      final_score = 0.5 * pace_score + 0.3 * step_score + 0.2 * speed_score

      if final_score > 0.7:
          return 'Run', final_score
      elif final_score < 0.3:
          return 'Walk', 1 - final_score
      else:
          return 'Mixed', 0.5

  Advanced ML Options:
  - Gaussian Mixture Model: Better handles overlapping activities
  - Random Forest: Can capture non-linear relationships
  - SVM with RBF kernel: Good for complex boundaries

  2. Database Storage Strategy

  Option A: Add columns to existing table:
  ALTER TABLE workout_summary
  ADD COLUMN predicted_activity_type VARCHAR(20),
  ADD COLUMN classification_confidence DECIMAL(3,2),
  ADD COLUMN classification_algorithm VARCHAR(50),
  ADD COLUMN classified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

  Option B: Separate classification table:
  CREATE TABLE workout_classifications (
      workout_id VARCHAR(20) PRIMARY KEY,
      predicted_type VARCHAR(20) NOT NULL,
      confidence DECIMAL(3,2) NOT NULL,
      algorithm_version VARCHAR(50) NOT NULL,
      features_used JSON,
      classified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (workout_id) REFERENCES workout_summary(workout_id)
  );

  3. Implementation Parameters

  Features to Include:
  - Primary: avg_pace, steps/(duration_sec/60)
  - Secondary: distance_mi/duration_sec, max_pace
  - Contextual: Time of day, day of week

  Confidence Thresholds:
  - High confidence: >0.8 (clear run/walk)
  - Medium confidence: 0.5-0.8 (mixed activities)
  - Low confidence: <0.5 (ambiguous/outliers)

  Validation Approach:
  - Use pace-based ground truth for clear cases (pace <10 = run, >20 = walk)
  - Cross-validation on historical data
  - A/B testing with manual labeling sample

  4. Recommended Next Steps

  1. Implement ensemble classifier in intelligence_service.py
  2. Add database columns for persistent storage
  3. Create validation pipeline using clear pace-based cases
  4. Add UI controls for reviewing/correcting classifications
  5. Implement batch re-classification when algorithm improves

  The mixed-activity challenge you mentioned is well-suited for the ensemble approach with confidence scoring, allowing users
   to understand classification certainty.
